#!/usr/bin/env node

/**
 * Module dependencies.
 */
var app = require('../app'); // Express app 인스턴스를 app.js로부터 가져옵니다.
var debug = require('debug')('server:server'); // 프로젝트 이름에 맞게 수정 가능 (예: 'privlychat-server:server')
var http = require('http');   // Node.js 내장 http 모듈
var WebSocket = require('ws'); // 설치한 ws 라이브러리
const { URLSearchParams } = require('url'); // URLSearchParams 사용을 위해 추가

/**
 * Get port from environment and store in Express.
 */
var port = normalizePort(process.env.PORT || '8888'); // Render가 PORT를 제공하면 그것을 사용
app.set('port', port);

/**
 * Create HTTP server using the Express app.
 */
var server = http.createServer(app); // ★★★ 'server' 변수 선언 및 정의 ★★★

/**
 * Create WebSocket server and attach it to the HTTP server.
 */
const wss = new WebSocket.Server({ server: server }); // ★★★ 생성된 'server' 변수 사용 ★★★
console.log('WebSocket 서버가 HTTP 서버에 통합되어 실행 준비 완료.');

// 연결된 클라이언트들을 관리하기 위한 객체
// key: userId, value: WebSocket 객체
const clients = new Map();

wss.on('connection', (ws, req) => {
  // 클라이언트가 연결될 때 userId를 쿼리 파라미터로 전달받습니다.
  // req.url은 '/?userId=alice_ws' 와 같은 형태입니다.
  const parameters = new URLSearchParams(req.url.slice(req.url.startsWith('/') ? 1 : 0));
  const userId = parameters.get('userId');

  if (!userId) {
    console.log('[WebSocket 서버] userId 없이 연결 시도됨. 연결 종료.');
    ws.terminate(); // userId가 없으면 연결 종료
    return;
  }

  // 이미 해당 userId로 연결된 클라이언트가 있는지 확인 (선택적: 중복 로그인 방지)
  if (clients.has(userId)) {
    console.log(`[WebSocket 서버] ${userId}는 이미 연결되어 있습니다. 이전 연결을 종료합니다.`);
    clients.get(userId).terminate();
  }

  // 새로운 클라이언트 등록
  clients.set(userId, ws);
  console.log(`[WebSocket 서버] 클라이언트 연결됨: ${userId} (총 ${clients.size}명)`);

  // 클라이언트로부터 메시지를 수신했을 때의 이벤트 핸들러
  ws.on('message', (message) => {
    console.log(`[WebSocket 서버] ${userId}로부터 메시지 수신: ${message.toString().slice(0, 100)}...`);

    try {
      const parsedMessage = JSON.parse(message.toString());

      if (parsedMessage.type === 'message' && parsedMessage.recipientId && parsedMessage.payload) {
        const recipientWs = clients.get(parsedMessage.recipientId);

        if (recipientWs && recipientWs.readyState === WebSocket.OPEN) {
          const messageToSend = JSON.stringify({
            type: 'message',
            senderId: userId,
            payload: parsedMessage.payload,
          });
          recipientWs.send(messageToSend);
          console.log(`[WebSocket 서버] ${userId}가 ${parsedMessage.recipientId}에게 메시지 전달 완료.`);
        } else {
          console.log(`[WebSocket 서버] 수신자 ${parsedMessage.recipientId}를 찾을 수 없거나 연결 상태가 좋지 않습니다.`);
          ws.send(JSON.stringify({
            type: 'error',
            message: `수신자 ${parsedMessage.recipientId}가 오프라인 상태입니다.`
          }));
        }
      } else {
        console.log(`[WebSocket 서버] ${userId}로부터 잘못된 형식의 메시지 수신:`, parsedMessage);
      }
    } catch (error) {
      console.error(`[WebSocket 서버] ${userId}로부터 받은 메시지 처리 중 오류:`, error);
      ws.send(JSON.stringify({
        type: 'error',
        message: '잘못된 메시지 형식입니다.'
      }));
    }
  });

  // 클라이언트 연결이 종료되었을 때의 이벤트 핸들러
  ws.on('close', () => {
    let closedUserId = null;
    for (const [id, clientWs] of clients.entries()) {
      if (clientWs === ws) {
        closedUserId = id;
        clients.delete(id);
        break;
      }
    }
    if (closedUserId) {
      console.log(`[WebSocket 서버] 클라이언트 연결 끊김: ${closedUserId} (총 ${clients.size}명)`);
    } else {
      console.log(`[WebSocket 서버] 클라이언트 연결 끊김 (ID 미확인).`);
    }
  });

  // 에러 발생 시 이벤트 핸들러
  ws.on('error', (error) => {
    console.error(`[WebSocket 서버] 클라이언트 ${userId || 'unknown'}에서 오류 발생:`, error); // userId가 없을 수도 있으므로 방어 코드
    if (userId && clients.has(userId) && clients.get(userId) === ws) { // userId가 있을 때만 clients에서 제거 시도
        clients.delete(userId);
        console.log(`[WebSocket 서버] 오류로 인해 ${userId} 연결 제거됨.`);
    }
  });

  // 연결 성공 메시지 (선택적)
  ws.send(JSON.stringify({ type: 'info', message: 'WebSocket 서버에 성공적으로 연결되었습니다.' }));
});

/**
 * Listen on provided port, on all network interfaces.
 */
server.listen(port); // HTTP 서버 시작 (WebSocket 서버도 함께 시작됨)
server.on('error', onError);
server.on('listening', onListening);

// normalizePort, onError, onListening 함수는 사용자님이 제공해주신 코드 그대로 사용합니다.
function normalizePort(val) {
  var port = parseInt(val, 10);
  if (isNaN(port)) { return val; }
  if (port >= 0) { return port; }
  return false;
}

function onError(error) {
  if (error.syscall !== 'listen') { throw error; }
  var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port;
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
  debug('Listening on ' + bind); // debug 모듈 사용
  console.log(`Privlychat™ HTTP 및 WebSocket 서버 통합 실행 중 (${bind})`);
}

// 서버 종료 시 모든 클라이언트 연결 정리 (선택적)
process.on('SIGINT', () => {
  console.log('[WebSocket 서버] SIGINT 수신. 종료 중... 모든 클라이언트 연결을 닫습니다.');
  clients.forEach((wsInstance, id) => { // 변수명 변경 (ws는 이미 사용 중)
    console.log(`[WebSocket 서버] ${id} 연결 닫는 중...`);
    wsInstance.close(1000, '서버가 종료됩니다.');
  });
  wss.close(() => {
    console.log('[WebSocket 서버] 완전히 종료됨.');
    server.close(() => { // HTTP 서버도 닫습니다.
        console.log('[HTTP 서버] 완전히 종료됨.');
        process.exit(0);
    });
  });
});